---
title: "Creating a TI method using docker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating a TI method using docker}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, message=FALSE}
library(tidyverse)
```

This vignette describes how to include your own method into the dynverse workflow. We'll illustrate this with a very basic method: using one of the components of a PCA as the pseudotime. The files for this example are also available at [https://github.com/dynverse/comp1](https://github.com/dynverse/comp1).

There are two main ways to add a new method:

* **Directly within R**. In this case you create an R function or R packages. The user will have to install all dependencies. This is use case is described in another vignette.
* **Using a docker**. In this case you create a docker which uses some input files (eg. a file containing the expression) and returns some output files. This use case is described here.

A TI docker requires at least three files.

* A definition yaml or json file, used to determine the format of input, output and parameters.
* A Dockerfile, used to construct the docker.
* Script(s) to load the data, run the method, and save the output

## Method definition file (`definition.yml`)

An example of a `definition.yml` file (as can be found on the [github](https://github.com/dynverse/comp1)):

```{r, echo=FALSE, results="asis"}
read_file("https://raw.githubusercontent.com/dynverse/comp1/master/R_text/definition.yml") %>%
  paste0("```yaml\n", ., "\n```") %>% 
  cat()
```

This yaml file contains:

#### name
A name of the method

#### parameters
A named list of parameters for the method. A parameter always has:

```{r, echo=FALSE}
parameter_types <- tribble(
  ~type, ~properties,
  "numeric", "lower, upper, trafo",
  "numeric_vector", "len, lower, upper, trafo",
  "integer", "lower, upper, trafo",
  "integer_vector", "len, lower, upper, trafo",
  "logical", "",
  "logical_vector", "len",
  "discrete", "values, trafo",
  "discrete_vector", "len, values"
)
```

- **type** The type of parameter, can be `r glue::collapse(paste0("\"", parameter_types$type, "\""), ", ", last=" or ")`
- **default** The default value


Moreover, parameters can also have other properties which define the parameter space used for parameter tuning.

```{r, echo=FALSE}
parameter_types %>% knitr::kable()
```

- **lower** and **upper** The lower and upper bounds
- **trafo** A transoformation function, eg. log
- **values** A list of values
- **len** Length of the parameter

#### input & input_optional

```{r}
github_url <- function(x, prefix) {
  if(length(x)) {
    glue::glue("[{x}](https://github.com/dynverse/dynwrap/blob/master/{prefix}{x})")
  } else {
    ""
  }
}
```


The input determines which kind of expression and prior information is given to the method. It contains the following properties:

- **format** The format of the input, which can be
    - `text`: csv or json files
    - `hdf5`: hdf5 files
    - `rds`: R binary files
- **required**: Required inputs (eg. expression)
- **optional**: Optional inputs (eg. start_cell_ids)

These requested required or optional inputs can be:

```{r}
data(allowed_inputs, package="dynwrap")
allowed_inputs %>% 
  knitr::kable()
```

```{r, echo=FALSE}
github_url <- function(x, prefix) {
  glue::glue("[{x}](https://github.com/dynverse/dynwrap/blob/master/{prefix}{x})")
}
```


#### output

The output determines what type of output is produced by the method, and how this can be transformed into a trajectory model.

- **format** The format of the output, which can be
    - `text`: csv or json files
    - `rds`: R binary files
    - `dynwrap`: A model directly generated by the dynwrap function
- **output_ids** The kinds of output this wrapper produces. Required is one type of output that contains enough information to be wrapped into the common trajectory format. Each of these outputs are further discussed in another vignette **link** , which also discuss the type of objects or files which need to be provided.

```{r, echo=FALSE}
data(allowed_outputs, package="dynwrap")
allowed_outputs %>% 
  filter(creates_trajectory) %>% 
  select(Output = output_id, Description = description, `Required files/objects` = required_params, `Optional files/objects` = optional_params) %>%
  mutate_if(is.list, ~map(., ~ifelse(length(.), glue::collapse(., ", "), ""))) %>% 
  knitr::kable()
```

In addition, a method can also generate other output which will also be added to the model, for example a grouping (`clustering`) or a dimensionality reduction (`dimred`). This can then be used 

```{r, echo=FALSE}
allowed_outputs %>% 
  filter(!creates_trajectory) %>% 
  select(output = output_id, description) %>% 
  knitr::kable()
```

## The `Dockerfile`

An example of a `Dockerfile` (as can be found on the [github](https://github.com/dynverse/comp1)):

```{r, echo=FALSE, results="asis"}
read_file("https://raw.githubusercontent.com/dynverse/comp1/master/R_text/Dockerfile") %>%
  paste0("```Dockerfile\n", ., "\n```") %>% 
  cat()
```

In this example, we add all the files present in the current working directory (which contains the run.R file) to the /code directory.

All dependencies of the method should be installed in this Dockerfile (or from parent docker images)

This file should always contain an entrypoint, which will be called when the TI method is run.

## Doing trajectory inference

All input files requested in the `definition.yml` will be mounted in the `/input` directory of the docker. After inferring a trajectory, the method should write output files into the `/output` directory. An example (as can be found on the [github](https://github.com/dynverse/comp1)):

```{r, echo=FALSE, results="asis"}
read_file("https://raw.githubusercontent.com/dynverse/comp1/master/R_text/run.R") %>%
  paste0("```r\n", ., "\n```") %>% 
  cat()
```

## Testing the TI method

Now we're all set to test the TI method on data. 

We first have to build the method (in shell) to an image:

```bash
docker build -t dynverse/comp1 .
```

Although this image can be run anywhere as long as the `/input` and `/output` folders are mounted, we'll run it here using the `dynwrap` workflow. First, we have to wrap the docker into a method function.
```r
library(dynwrap)
ti_comp1 <- create_docker_ti_method("dynverse/comp1")
```

```{r, echo=FALSE}
library(dynwrap)
```

If the method is on the docker hub, it can also be pulled
```{r}
ti_comp1 <- pull_docker_ti_method("dynverse/comp1")
```

Then we'll use some test data
```{r}
ncells <- 1000
pseudotime <- runif(ncells)

expression <- matrix(
  c(
    (pseudotime - 0.5) ** 2,
    sqrt(pseudotime + 20),
    pseudotime
  ),
  ncol = 3,
  dimnames = list(as.character(rep(seq_len(ncells))), as.character(c("A", "B", "C")))
)
expression <- expression + rnorm(length(expression), sd = 0.02)

start_cells = rownames(expression)[which.min(pseudotime)]

counts <- round(expression)

task <- wrap_expression(
  expression,
  counts
) %>% add_prior_information(start_cells=start_cells)
```

Now infer a trajectory
```{r}
model <- infer_trajectory(task, ti_comp1())
```

```{r}
if ("dynplot" %in% rownames(installed.packages())) {
  dynplot::plot_dimred(model, color_cells = "pseudotime" , expression_source = task$expression)
}
```


Give some optional prior information
```{r}
model <- infer_trajectory(task, ti_comp1(), give_priors = "start_cells")
```

```{r}
if ("dynplot" %in% rownames(installed.packages())) {
  dynplot::plot_dimred(model, color_cells = "pseudotime" , expression_source = task$expression)
}
```

