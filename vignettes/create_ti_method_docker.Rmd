---
title: "Creating a TI method using docker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating a TI method using docker}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, message=FALSE}
library(tidyverse)
```

This vignette describes how to include your own method into the dynverse workflow. We'll illustrate this with a very basic method: using one of the components of a PCA as the pseudotime. The files for this example are also available at [https://github.com/dynverse/comp1](https://github.com/dynverse/comp1).

There are two main ways to add a new method:

* **Directly within R**. In this case you create an R function or R packages. The user will have to install all dependencies. This is use case is described in another vignette.
* **Using a docker**. In this case you create a docker which uses some input files (eg. a file containing the expression) and returns some output files. This use case is described here.

A TI docker requires at least three files.

* A definition yaml or json file, used to determine the format of input, output and parameters.
* A Dockerfile, used to construct the docker.
* Script(s) to load the data, run the method, and save the output

## Method definition file (`definition.yml`)

An example of a `definition.yml` file (as can be found on the [github](https://github.com/dynverse/comp1)):

```{r, echo=FALSE, results="asis"}
read_file("https://raw.githubusercontent.com/dynverse/comp1/master/definition.yml") %>%
  paste0("```yaml\n", ., "\n```") %>% 
  cat()
```

This yaml file contains:

#### name
A name of the method

#### image

The name of the image to use, can be a local name or a name from the [docker hub](https://hub.docker.com/)

#### parameters
A named list of parameters for the method. Each parameter should at least have the following two properties:

```{r, echo=FALSE}
parameter_types <- tribble(
  ~type, ~properties,
  "numeric", "lower, upper, trafo",
  "numeric_vector", "len, lower, upper, trafo",
  "integer", "lower, upper, trafo",
  "integer_vector", "len, lower, upper, trafo",
  "logical", "",
  "logical_vector", "len",
  "discrete", "values, trafo",
  "discrete_vector", "len, values"
)
```


- **type** The type of parameter, can be `r glue::collapse(paste0("\"", parameter_types$type, "\""), ", ", last=" or ")`
- **default** The default value
    
Each type can have addition properties, which define the parameter space

```{r, echo=FALSE}
parameter_types %>% knitr::kable()
```

- **lower** and **upper** The lower and upper bounds
- **trafo** A transoformation function, eg. log
- **values** A list of values
- **len** Length of the parameter

#### input
```{r, echo=FALSE}
github_url <- function(x, prefix) {
  glue::glue("[{x}](https://github.com/dynverse/dynwrap/blob/master/{prefix}{x})")
}
```

A list of required inputs, can be:
```{r, echo=FALSE}
dynwrap:::input_processors %>% 
  mutate(file = github_url(file, "inst/example_inputs/")) %>% 
  select(input=id, `File` = file, `Description`=description) %>% 
  knitr::kable()
```


#### output

A list of outputs, can be:

```{r, echo=FALSE}
github_url <- function(x, prefix) {
  if(length(x)) {
    glue::glue("[{x}](https://github.com/dynverse/dynwrap/blob/master/{prefix}{x})")
  } else {
    ""
  }
}

dynwrap:::output_processors %>% 
  mutate_at(
    c("required_files", "optional_files"),
    ~map(
      ., 
      function(files) {
        github_url(files, "inst/example_outputs/") %>% 
          glue::collapse(", ")
      })
  ) %>% 
  mutate(
    creates_trajectory = ifelse(creates_trajectory, "âœ”", ""),
    required_output = map_chr(required_output, paste0, collapse= ", ")
  ) %>% 
  select(
    name=id, 
    `Required files` = required_files, 
    `Optional files` = optional_files,
    `Description`=description, 
    `Creates trajectory`=creates_trajectory,
    `Required outputs` = required_output
  ) %>% 
  knitr::kable()
```


## The `Dockerfile`

An example of a `Dockerfile` (as can be found on the [github](https://github.com/dynverse/comp1)):

```{r, echo=FALSE, results="asis"}
read_file("https://raw.githubusercontent.com/dynverse/comp1/master/Dockerfile") %>%
  paste0("```Dockerfile\n", ., "\n```") %>% 
  cat()
```

In this example, we add all the files present in the current working directory (which contains the run.R file) to the /code directory.

All dependencies of the method should be installed in this Dockerfile (or from parent docker images)

This file should always contain an entrypoint, which will be called when the TI method is run.

## Doing trajectory inference

All input files requested in the `definition.yml` will be mounted in the `/input` directory of the docker. After inferring a trajectory, the method should write output files into the `/output` directory. An example (as can be found on the [github](https://github.com/dynverse/comp1)):

```{r, echo=FALSE, results="asis"}
read_file("https://raw.githubusercontent.com/dynverse/comp1/master/run.R") %>%
  paste0("```r\n", ., "\n```") %>% 
  cat()
```

## Running the TI method

Now we're all set to test the TI method on data. We first have to build the method (in shell)

```bash
docker build -t dynverse/comp1 .
```

Although this docker can be run in any programming language, we'll run it here using the `dynwrap` workflow. First, we have to wrap the docker into a method function.
```r
ti_comp1 <- create_docker_ti_method("dynverse/comp1")
```

If the method is on the docker hub, it can also be pulled
```{r}
library(dynwrap)
ti_comp1 <- dynwrap::pull_docker_ti_method("dynverse/comp1")
```

Then we'll use some test data
```{r}
ncells <- 1000
pseudotime <- runif(ncells)

expression <- matrix(
  c(
    (pseudotime - 0.5) ** 2,
    sqrt(pseudotime + 20),
    pseudotime
  ),
  ncol = 3,
  dimnames = list(as.character(rep(seq_len(ncells))), as.character(c("A", "B", "C")))
)
expression <- expression + rnorm(length(expression), sd = 0.02)

counts <- round(expression)

task <- wrap_expression(
  expression,
  counts
) %>% add_prior_information(start_cells = rownames(expression)[which.min(pseudotime)])
```

Now infer a trajectory
```{r}
model <- infer_trajectory(task, ti_comp1())
```

