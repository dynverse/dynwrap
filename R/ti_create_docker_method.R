#' Create a TI method from a docker(hub) image
#'
#' `create_docker_ti_method` will use a local docker image, `pull_docker_ti_method` will pull the latest docker image from the docker hub
#'
#' @param image The name of the image. Required
#' @param name The name of the method. Optional, will be extracted from the image definition.yml file
#' @param input Input data, such as expression, counts or prior_information
#' @param output Output generated by the method
#' @param par_set The parameter set as created by [ParamHelpers::makeParamSet]
#' @param parameters A named list of parameters, containing the type of parameter and additional parameters such as lower and upper bounds, default value and/or possible values. Optional, will be extracted from the image definition.yml file
#' @param definition A list containing the name, image, input, output and parameters of a method. Usually used for when these values are loaded from a yaml or json file
#' @param docker_client Optional, a [stevedore::docker_client()]
#'
#' @importFrom jsonlite write_json read_json
#' @importFrom glue glue
#'
#' @export
create_docker_ti_method <- function(
  image,
  name = NULL,
  input = NULL,
  output = NULL,
  par_set = NULL,
  parameters = NULL,
  definition = NULL,
  docker_client = stevedore::docker_client()
) {
  requireNamespace("crayon")
  requireNamespace("yaml")

  testthat::expect_s3_class(docker_client, "docker_client")

  # extract from image if required parameters are not specified
  if (any(map_lgl(list(name, input, output), is.null))) {
    message("Extracting method definition from image definitions.yml file")

    temp_container <- docker_client$container$create(
      image,
      "bash",
      entrypoint="bash"
    )
    definition_path <- tempfile()
    system(glue("docker cp {temp_container$id()}:/code/definition.yml {definition_path}"))
    temp_container$remove()

    definition <- yaml::read_yaml(definition_path)
  }

  # extract parameters from definition if given
  if (!is.null(definition)) {
    if(is.null(name)) name <- definition$name
    if(is.null(input)) input <- definition$input
    if(is.null(output)) output <- definition$output
    if(is.null(parameters) && is.null(par_set)) parameters <- definition$parameters
  }

  testthat::expect_true(is.character(name))
  testthat::expect_true(is.character(image))
  testthat::expect_true(is.character(input))
  testthat::expect_true(is.character(output))

  # parse parameters
  if(is.null(par_set)) {
    if(is.null(parameters)) stop("parameters is required if par_set is not given")

    par_set <- parse_parameter_definition(parameters)
  }

  # extract the input, params and output
  input_ids <- input
  param_ids <- names(par_set$pars)
  output_ids <- output

  if (!any(input_ids %in% input_processors$id)) {
    stop("Invalid input_ids: ", setdiff(input_ids, input_processors$id))
  }

  if (!any(output_ids %in% output_processors$id)) {
    stop("Invalid output_ids: ", setdiff(input_ids, output_processors$id))
  }

  # define run_fun
  run_fun <- function() {
    # create input directory
    dir_input <- file.path(tempdir(), "input")
    if(dir.exists(dir_input)) {
      unlink(dir_input)
    } else {
      dir.create(dir_input)
    }

    # create output directory
    dir_output <- file.path(tempdir(), "output")
    if(dir.exists(dir_output)) {
      unlink(dir_output)
    } else {
      dir.create(dir_output)
    }

    # save inputs
    for (input_id in input_ids) {
      save_input(get(input_id, environment()), input_id, file.path(dir_input, input_id))
    }

    # save params
    params <- map(param_ids, get, environment()) %>% set_names(param_ids)
    write_json(params, file.path(dir_input, "params.json"))

    # print provided input files
    list.files(dir_input) %>%
      crayon::bold() %>%
      glue::collapse("\n\t") %>%
      paste0("input: \n\t", ., "\n") %>%
      cat

    # run docker image
    docker <- stevedore::docker_client()

    docker_client$container$run(
      image,
      volumes=c(
        glue("{dir_input}:/input"),
        glue("{dir_output}:/output")
      )
    )

    # print found output files
    list.files(dir_output) %>%
      crayon::bold() %>%
      glue::collapse("\n\t") %>%
      paste0("output: \n\t", ., "\n") %>%
      cat

    # wrap output
    if(exists("counts")) {cell_ids <- rownames(counts)} else {cell_ids <- rownames(expression)}
    model <- wrap_data(cell_ids = cell_ids) %>%
      wrap_output(output_ids, dir_output)

    model
  }

  # adapt run_fun environment
  environment(run_fun) <- list2env(lst(input_ids, param_ids, output_ids))

  # adapt run_fun arguments
  argument_ids <- c(input_ids, param_ids)
  arguments <- c(
    rep(list(expr()), length(argument_ids)) %>% set_names(argument_ids),
    alist(docker_client=stevedore::docker_client()) # default docker_client arguments
  )
  formals(run_fun) <- arguments

  # create ti_method
  create_ti_method(
    name,
    par_set,
    run_fun
  )
}


#' @rdname create_docker_ti_method
#' @export
pull_docker_ti_method <- function(
  image,
  docker_client = stevedore::docker_client()
) {
  docker_client$image$pull(image)

  create_docker_ti_method(image, docker_client=docker_client)
}
