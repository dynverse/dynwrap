#' Create a TI method from a docker(hub) image
#'
#' `create_docker_ti_method` will use a local docker image, `pull_docker_ti_method` will pull the latest docker image from the docker hub
#'
#' @param image The name of the image. Required
#' @param name The name of the method. Optional, will be extracted from the image definition.yml file
#' @param input_ids_required Names of required input data, such as expression, counts or some [priors]
#' @param input_ids_optional Names of optional input data, such as expression, counts, or some [priors]
#' @param input_format The format of the input, can be hdf5, text or rds
#' @param output_ids Output generated by the method
#' @param output_format The format of the output, can be hdf5, text or rds
#' @param par_set The parameter set as created by [ParamHelpers::makeParamSet]
#' @param parameters A named list of parameters, containing the type of parameter and additional parameters such as lower and upper bounds, default value and/or possible values. Optional, will be extracted from the image definition.yml file
#' @param definition A list containing the name, image, input, output and parameters of a method. Usually used for when these values are loaded from a yaml or json file
#' @param docker_client Optional, a [stevedore::docker_client()]
#'
#' @importFrom jsonlite write_json read_json
#' @importFrom glue glue
#'
#' @export
create_docker_ti_method <- function(
  image,
  name = NULL,
  input_ids_required = NULL,
  input_ids_optional = NULL,
  input_format = NULL,
  output_ids = NULL,
  output_format = NULL,
  par_set = NULL,
  parameters = NULL,
  definition = NULL,
  docker_client = stevedore::docker_client()
) {
  requireNamespace("crayon")
  requireNamespace("yaml")

  testthat::expect_s3_class(docker_client, "docker_client")

  # extract the definition from an image if required parameters are not specified
  if (any(map_lgl(list(name, input_ids_required, output_ids), is.null))) {
    message("Extracting method definition from image definitions.yml file")

    temp_container <- docker_client$container$create(
      image,
      "bash",
      entrypoint="bash"
    )
    definition_path <- tempfile()
    system(glue("docker cp {temp_container$id()}:/code/definition.yml {definition_path}"))
    temp_container$remove()

    definition <- yaml::read_yaml(definition_path)
  }

  # extract parameters from definition if given
  if (!is.null(definition)) {
    if(is.null(name)) name <- definition$name
    if(is.null(input_ids_required)) input_ids_required <- definition$input$required
    if(is.null(input_ids_optional)) input_ids_optional <- definition$input$optional
    if(is.null(output_ids)) output_ids <- definition$output$outputs
    if(is.null(parameters) && is.null(par_set)) parameters <- definition$parameters
    if(is.null(input_format)) {
      if(is.null(definition$input$format)) {
        message("No input_format specified, using feather")
        input_format <- "hdf5"
      }  else {
        if (length(definition$input$format) > 1) {
          message("Available input_formats are: ", glue::collapse(definition$input$format, ", "), ", using first")
        }

        input_format <- definition$input$format[[1]]
      }
    }
    if(is.null(output_format)) {
      if(is.null(definition$output$format)) {
        message("No output_format specified, using feather")
        output_format <- "feather"
      }  else {
        if (length(definition$output$format) > 1) {
          message("Available output_formats are: ", glue::collapse(definition$output$format, ", "), ", using first")
        }
        output_format <- definition$output$format[[1]]
      }
    }
  }

  testthat::expect_true(is.character(name))
  testthat::expect_true(length(input_ids_required) > 0)
  testthat::expect_true(is.character(input_ids_required))
  testthat::expect_true(is.character(input_ids_optional))
  testthat::expect_true(is.character(input_format))
  testthat::expect_true(is.null(output_ids) || is.character(output_ids))
  testthat::expect_true(is.character(output_format))

  # parse parameters
  if(is.null(par_set)) {
    if(is.null(parameters)) stop("parameters is required if par_set is not given")

    par_set <- parse_parameter_definition(parameters)
  }

  param_ids <- names(par_set$pars)

  # parse input ids
  input_ids <- c(input_ids_required, input_ids_optional)

  data(allowed_inputs, package="dynwrap", envir=environment())
  if (!all(input_ids %in% allowed_inputs$input_id)) {
    stop("Invalid input: ", setdiff(input_ids, allowed_inputs$input_id), ". See dynwrap:::get_allowed_inputs()")
  }

  # parse output_ids
  data(allowed_outputs, package="dynwrap", envir=environment())
  if (length(output_ids) && !all(output_ids %in% allowed_outputs$output_id)) {
    stop("Invalid output: ", setdiff(output_ids, allowed_outputs$output_id), ". See dynwrap:::get_allowed_outputs()")
  }

  # define run_fun
  run_fun <- function() {
    # create input directory
    dir_input <- file.path(tempdir(), "input")
    if(dir.exists(dir_input)) {
      unlink(paste0(dir_input, "/*"))
    } else {
      dir.create(dir_input)
    }

    # save data & params, see save_inputs function
    save_inputs(environment(), dir_input, input_format, input_ids, c(param_ids, "input_format", "output_format"))

    # print provided input files
    list.files(dir_input) %>%
      crayon::bold() %>%
      glue::collapse("\n\t") %>%
      paste0("input saved to ", dir_input, ": \n\t", ., "\n") %>%
      cat

    # create output directory
    dir_output <- file.path(tempdir(), "output")
    if(dir.exists(dir_output)) {
      unlink(paste0(dir_output, "/*"))
    } else {
      dir.create(dir_output)
    }

    # run docker image
    docker <- stevedore::docker_client()


    if (debug) {
      cat(glue::glue("Debug: docker run --entrypoint 'bash' -it -v {dir_input}:/input -v {dir_output}:/output {image}\n\n"))
    }

    docker_client$container$run(
      image,
      volumes=c(
        glue("{dir_input}:/input"),
        glue("{dir_output}:/output")
      )
    )


    # print found output files
    list.files(dir_output) %>%
      crayon::bold() %>%
      glue::collapse("\n\t") %>%
      paste0("output saved in ", dir_output, ": \n\t", ., "\n") %>%
      cat

    # wrap output
    if("counts" %in% input_ids) {cell_ids <- rownames(counts)} else {cell_ids <- rownames(expression)}
    model <- wrap_data(cell_ids = cell_ids) %>%
      wrap_output(output_ids, dir_output, output_format)

    model
  }

  # adapt run_fun environment
  environment(run_fun) <- list2env(lst(input_ids, param_ids, output_ids))

  # adapt run_fun arguments, some hocus pocus going on here ;)
  # the `list(expr())` creates a required function argument
  argument_ids <- c(input_ids, param_ids)
  arguments <- c(
    rep(list(expr()), length(input_ids_required)) %>% set_names(input_ids_required),
    rep(list(expr()), length(param_ids)) %>% set_names(param_ids),
    rep(list(NULL), length(input_ids_optional)) %>% set_names(input_ids_optional),
    alist(
      docker_client = stevedore::docker_client(),
      debug = FALSE
    ), # default arguments (evaluated when running run_fun)
    list(
      output_format = output_format,
      input_format = input_format
    ) # default arguments (evaluated now)
  )
  formals(run_fun) <- arguments

  # create ti_method
  create_ti_method(
    name,
    par_set,
    run_fun
  )
}

#' @rdname create_docker_ti_method
#' @export
pull_docker_ti_method <- function(
  image,
  docker_client = stevedore::docker_client()
) {
  docker_client$image$pull(image)

  create_docker_ti_method(image, docker_client=docker_client)
}

save_inputs <- function(
  envir,
  dir_input,
  input_format = c("hdf5", "text", "rds", "feather"),
  input_ids = NULL,
  param_ids = NULL
) {
  input_format <- match.arg(input_format)

  params <- map(param_ids, get, envir) %>% set_names(param_ids)
  inputs <- map(input_ids, get, envir) %>% set_names(input_ids) %>% discard(is.null)

  # save data depending on the input_format
  if(input_format == "text") {
    for (input_id in names(inputs)) {
      input <- inputs[[input_id]]
      if(is.matrix(input)) {
        write.csv(input, glue::glue("{dir_input}/{input_id}.csv"))
      } else if (is.data.frame(input)) {
        write_csv(input, glue::glue("{dir_input}/{input_id}.csv"))
      } else {
        jsonlite::write_json(input, glue::glue("{dir_input}/{input_id}.json"))
      }
    }
  } else if (input_format == "rds") {
    write_rds(inputs, file.path(dir_input, "data.rds"))
  } else if (input_format == "hdf5") {
    file <- hdf5r::H5File$new(file.path(dir_input, "data.h5"), "w")
    purrr::walk2(inputs, names(inputs), function(x, name) {
      file$create_dataset(name, x)

      if(is.matrix(x)) {
        hdf5r::h5attr(file[[name]], "rownames") <- rownames(x)
        hdf5r::h5attr(file[[name]], "colnames") <- colnames(x)
      }
    })
    file$close_all() # important to do a close_all here, otherwise some parts of the data can still be open, resulting invalid h5 files

  } else if (input_format == "feather") {
    requireNamespace("feather")
    for (input_id in names(inputs)) {
      input <- inputs[[input_id]]
      if(is.matrix(input)) {
        feather::write_feather(input %>% as.data.frame() %>% rownames_to_column("rownames"), glue::glue("{dir_input}/{input_id}.feather"))
      } else if (is.data.frame(input)) {
        feather::write_feather(input, glue::glue("{dir_input}/{input_id}.feather"))
      } else if (is.vector(input) ){
        feather::write_feather(tibble(!!input_id := input), glue::glue("{dir_input}/{input_id}.feather"))
      } else {
        stop("Feather does not support this output")
      }
    }
  }

  # save params as json
  write_json(params, file.path(dir_input, "params.json"), auto_unbox = TRUE)
}

