#' Wrap the output of a TI method
#'
#' Will extract outputs from a given folder given an output format:
#'  * rds: One `output.rds` file containing all the output. Output can be present as `.$pseudotime` or as `.$linear_trajectory$pseudotime` . Parameters specific for an output should be given in `.$linear_trajectory$params`
#'  * text: Csv and/or json files, including subdirectories. Output can be present as `./pseudotime.csv` or as `./linear_trajectory/pseudotime.csv`. Parameters specific for an output should be given in `./linear_trajectory/params.json`.
#'  * feather: Feather files
#'  * dynwrap: Directly a dynwrap wrapper as an rds file in `output.rds`
#'
#' @param model The model to start from, as generated by `wrap_data`
#' @param output_ids The ids of the outputs generated by the methods
#' @param dir_output The directory containing the output files
#' @param output_format The output format, can be rds, text or dynwrap
#'
#' @export
wrap_output <- function(cell_ids, output_ids, dir_output, output_format = c("text", "rds", "feather", "dynwrap")) {
  output_format <- match.arg(output_format)
  if(output_format == "rds") {
    wrap_rds(cell_ids, output_ids, dir_output)
  } else if (output_format == "text") {
    wrap_text(cell_ids, output_ids, dir_output)
  } else if (output_format == "feather") {
    wrap_feather(cell_ids, output_ids, dir_output)
  } else if (output_format == "dynwrap") {
    read_rds(file.path(dir_output, "output.rds"))
  }
}

#' @rdname wrap_output
wrap_rds <- function(cell_ids, output_ids, dir_output) {
  output <- read_rds(file.path(dir_output, "output.rds"))

  if ("cell_ids" %in% names(output)) {
    cell_ids <- output$cell_ids
    output$cell_ids <- NULL
  }

  model <- wrap_data(cell_ids = cell_ids)

  for (output_id in output_ids) {
    processor <- get_output_processor(output_id)

    # define output from which to extract variables
    output_for_extraction <- output

    # also include output[[output_id]] if it is a list and not a dataframe
    if (is.list(output[[output_id]]) && !is.data.frame(output[[output_id]])) {
      output_for_extraction <- c(
        output_for_extraction,
        output[[output_id]]
      )
    }

    output_oi <- c(
      output_for_extraction[intersect(processor$args, names(output_for_extraction))]
    )

    # always give model as first argument
    output_oi <- c(
      list(model),
      output_oi
    )

    model <- invoke(processor$processor, output_oi)
  }
  model
}

#' @rdname wrap_output
wrap_text <- function(cell_ids, output_ids, dir_output) {
  outer_files <- list.files(dir_output, full.names = TRUE)

  ix <- grep("cell_ids[^/]*", outer_files)
  if (length(ix) > 0) {
    file <- outer_files[[ix]]
    cell_ids <- read_infer(file, "cell_ids") %>% pull(cell_ids)
    outer_files <- outer_files[-ix]
  }

  model <- wrap_data(cell_ids = cell_ids)

  for (output_id in output_ids) {
    output_oi <- list()

    processor <- get_output_processor(output_id)

    inner_files <- list.files(file.path(dir_output, output_id), all.files = TRUE)

    files <- c(inner_files, outer_files)

    for(arg in processor$args) {
      matching <- stringr::str_subset(files, glue::glue(".*\\/{arg}\\..*"))
      if(length(matching)) {
        output_oi[[arg]] <- read_infer(first(matching), arg)
      }
    }

    # also add extra params for this output
    matching <- stringr::str_subset(files, glue::glue(".*{arg}[_/]params.json"))
    if (length(matching)) {
      output_oi <- c(
        output_oi,
        jsonlite::read_json(first(matching))
      )
    }

    # always give model as first argument
    output_oi <- c(
      list(model),
      output_oi
    )

    model <- invoke(processor$processor, output_oi)
  }
  model
}

#' @rdname wrap_output
wrap_feather <- function(cell_ids, output_ids, dir_output) {
  # install feather if not available
  dynutils::install_packages("feather", "dynwrap", prompt = TRUE)
  requireNamespace("feather")

  outer_files <- list.files(dir_output, full.names = TRUE)

  ix <- grep("cell_ids[^/]*", outer_files)
  if (length(ix) > 0) {
    file <- outer_files[[ix]]
    cell_ids <- feather::read_feather(file) %>% pull(cell_ids)
    outer_files <- outer_files[-ix]
  }

  model <- wrap_data(cell_ids = cell_ids)

  for (output_id in output_ids) {
    output_oi <- list()

    processor <- get_output_processor(output_id)

    inner_files <- list.files(file.path(dir_output, output_id), all.files = TRUE)

    files <- c(inner_files, outer_files)

    for(arg in processor$args) {
      matching <- stringr::str_subset(files, glue::glue(".*\\/{arg}.feather"))
      if(length(matching)) {
        output_oi[[arg]] <- feather::read_feather(first(matching))
      }
    }

    # also add extra params, both from the output_id folder as well as from the main folder
    if(file.exists(file.path(dir_output, output_id, "params.json"))) {
      output_oi <- c(
        output_oi,
        jsonlite::read_json(file.path(dir_output, output_id, "params.json"))
      )
    }

    # feather can only save tibbles, if something else needs to be saved it will be saved as a one-column tibble with colname equal to output_id
    # here we simplify this again to a vector
    # alternatively: if we need a named vector, the tibble will contain a column with "name"
    output_oi <- map2(output_oi, names(output_oi), function(x, name) {
      if(is.data.frame(x) && ncol(x) == 1 && colnames(x) == name) {
        x[[name]]
      } else if (is.data.frame(x) && ncol(x) == 2 && c("name", name) %in% colnames(x)) {
        set_names(x[[name]], x[["name"]])
      } else {
        x
      }
    })

    # always give model as first argument
    output_oi <- c(
      list(model),
      output_oi
    )


    model <- invoke(processor$processor, output_oi)
  }
  model
}


# read text output -----------------------------
# specify how to read a text output
output_object_specifications <- list(
  cell_ids = cols(
    cell_ids = col_character()
  ),
  pseudotime = cols(
    cell_id = col_character(),
    pseudotime = col_double()
  ),
  milestone_network = cols(
    from = col_character(),
    to = col_character(),
    length = col_double(),
    directed = col_logical()
  ),
  dimred = cols(
    cell_id = col_character(),
    .default = col_double()
  ),
  dimred_milestones = cols(
    milestone_id = col_character(),
    .default = col_double()
  ),
  divergence_regions = cols(
    milestone_id = col_character(),
    divergence_id = col_character(),
    is_start = col_logical()
  ),
  milestone_percentages = cols(
    cell_id = col_character(),
    milestone_id = col_character(),
    percentage = col_double()
  ),
  progressions = cols(
    cell_id = col_character(),
    from = col_character(),
    to = col_character(),
    percentage = col_double()
  ),
  branch_network = cols(
    from = col_character(),
    to = col_character()
  ),
  branches = cols(
    branch_id = col_character(),
    length = col_double(),
    directed = col_logical()
  ),
  branch_progressions = cols(
    cell_id = col_character(),
    branch_id = col_character(),
    percentage = col_double()
  ),
  cell_ids = function(x) as.character(unlist(x)),
  cell_graph = cols(
    from = col_character(),
    to = col_character()
  ),
  to_keep = function(x) as.character(unlist(x)),
  group_ids = function(x) as.character(unlist(x)),
  grouping = cols(
    cell_id = col_character(),
    group_id = col_character()
  ),
  milestone_ids = function(x) as.character(unlist(x)),
  end_state_probabilities = cols(
    cell_id = col_character(),
    .default = col_double()
  ),
  timings = function(x) x
)
# read text output
read_infer <- function(file, arg) {
  if(arg %in% names(output_object_specifications)) {
    # read as csv or json depending on the specification
    specification <- output_object_specifications[[arg]]
    if(is.function(specification)) {
      object <- specification(jsonlite::read_json(file, TRUE))
    } else {
      object <- read_csv(file, col_types = specification)
    }
  } else {
    stop("No specification for > ", arg)
  }

  object
}


get_output_processor <- function(output_id) {
  requireNamespace("dynwrap")
  processor <- get(paste0("add_", output_id))

  required_args <- names(as.list(formals(processor)) %>% map_chr(class) %>% keep(~. == "name"))
  required_args <- setdiff(required_args, c("data_wrapper", "traj", "model", "pred", "object", "trajectory", "..."))
  optional_args <- names(as.list(formals(processor)) %>% map_chr(class) %>% keep(~. != "name"))

  lst(
    processor,
    required_args,
    optional_args,
    args = c(required_args, optional_args)
  )
}
